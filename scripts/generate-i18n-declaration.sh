#!/bin/bash

# i18n declaration generator script
# Generates type declaration file for next-intl modular structure

set -e

if ! command -v jq &> /dev/null; then
    echo "âš ï¸  jq is not installed. Please install it to continue. (e.g., 'brew install jq' or 'sudo apt-get install jq')" >&2; exit 1
fi

echo "ğŸ”„ Generating i18n declaration file..."

# Define paths
MODULES_PATH="./messages/en"
DECLARATION_FILE="./messages/declarations.json"

# Auto-discover modules by scanning the directory
MODULE_FILES=()
if [ -d "$MODULES_PATH" ]; then
    echo "ğŸ“‚ Scanning modules directory: $MODULES_PATH"
    # Use find to get all .json files recursively
    while IFS= read -r -d $'\0' file; do
        MODULE_FILES+=("$file")
        echo "ğŸ” Found module file: $file"
    done < <(find "$MODULES_PATH" -name "*.json" -print0)
else
    echo "âš ï¸  Modules directory not found: $MODULES_PATH"
    echo "ğŸ“ Creating modules directory..."
    mkdir -p "$MODULES_PATH"
fi

# If no module files found, create a default one
if [ ${#MODULE_FILES[@]} -eq 0 ]; then
    echo "âš ï¸  No modules found, creating default modules..."
    DEFAULT_MODULE_FILE="$MODULES_PATH/common.json"
    echo "{}" > "$DEFAULT_MODULE_FILE"
    MODULE_FILES+=("$DEFAULT_MODULE_FILE")
    echo "âœ¨ Created default module: common"
fi

echo "ğŸ“‹ Total module files found: ${#MODULE_FILES[@]}"

# Use jq to merge module files into a single JSON object.
# The key is generated by taking only the filename (without extension) from the input_filename.
# Example: ./messages/en/website/contact.json -> contact
DECLARATION=$(jq -n '[inputs | {key: (input_filename | sub(".*/"; "") | rtrimstr(".json")), value: .}] | from_entries' "${MODULE_FILES[@]}")

# Format the merged JSON with Prettier and write it to the declaration file.
echo "$DECLARATION" | pnpm exec prettier --parser json > "$DECLARATION_FILE"

echo "âœ… Generated declaration file: $DECLARATION_FILE"
echo "ğŸ‰ i18n declaration generation completed!"